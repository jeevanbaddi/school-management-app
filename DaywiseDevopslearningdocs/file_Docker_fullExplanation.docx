1ï¸âƒ£ What is a Dockerfile? (Definition â€“ Interview Ready)
ğŸ”‘ Definition

A Dockerfile is a text file that contains a set of instructions used by Docker to build a container image in a layered, reproducible way.

ğŸ”‘ In simple words

Dockerfile = Recipe

Docker image = Prepared dish

Docker container = Dish being served & eaten

ğŸ”‘ MUST KNOW (4+ Years)

Dockerfile is not executed line-by-line at runtime

It is used only during image build

Each instruction creates a read-only layer

Layers are cached & reused

2ï¸âƒ£ How Dockerfile Works Internally (IMPORTANT)

When you run:

docker build -t school-app .


Docker does:

Reads Dockerfile top to bottom

Executes each instruction

Creates an image layer

Caches that layer

Final image = stack of layers

ğŸ‘‰ This is why instruction order matters.

3ï¸âƒ£ General Dockerfile Syntax (Standard Format)

Most production Dockerfiles follow this pattern:

FROM <base-image>

WORKDIR <directory>

COPY <dependency-files>
RUN <install dependencies>

COPY <application-code>

EXPOSE <port>

CMD / ENTRYPOINT

ğŸ”‘ MUST KNOW

FROM â†’ mandatory

CMD or ENTRYPOINT â†’ mandatory

Order affects:

Build speed

Image size

CI performance

4ï¸âƒ£ Now YOUR Dockerfile â€“ Line by Line (DEEP EXPLANATION)
ğŸ”¹ FROM python:3.10-slim
What it means

Uses official Python Docker image

Python version = 3.10

OS = Debian slim

ğŸ”‘ Why Python 3.10?

Stable

Long-term support

Compatible with Flask & pytest

Widely used in production

ğŸ”‘ Why NOT latest?

âŒ latest can break builds
âœ” Fixed version ensures reproducibility

ğŸ”‘ Why -slim?

Smaller image size

Faster pull

Reduced attack surface

Image	Size
python:3.10	~900 MB
python:3.10-slim	~120 MB

ğŸ‘‰ Senior engineers always prefer slim

ğŸ”¹ WORKDIR /app
What it does

Creates /app inside container

Sets it as default directory

All future commands run from /app

Equivalent to:
cd /app

ğŸ”‘ Why is this important?

Avoids absolute paths

Cleaner Dockerfile

Prevents permission issues

âš ï¸ COMMON MISTAKE

âŒ Not setting WORKDIR
âœ” Leads to messy paths like /app/app/main.py

ğŸ”¹ COPY requirements.txt .
What it does

Copies requirements.txt from host â†’ container /app

ğŸ”‘ WHY copy this FIRST? (VERY IMPORTANT)

This is called Docker Layer Caching Optimization.

Scenario:

You change app code

Dependencies stay same

Docker will:
âœ” Reuse cached dependency layer
âœ” Skip reinstalling packages
âœ” Build faster

âš ï¸ COMMON MISTAKE

âŒ Copy entire code first
âŒ Then install dependencies
âœ” This causes slow builds

ğŸ”¹ RUN pip install --no-cache-dir -r requirements.txt
What it does

Installs Python dependencies inside image

ğŸ”‘ Why --no-cache-dir?

Prevents pip cache storage

Reduces image size

Cleaner image

ğŸ”‘ MUST KNOW

RUN executes during image build

Creates a permanent image layer

ğŸ”¹ COPY . .
What it does

Copies entire project into /app

ğŸ”‘ Why AFTER dependencies?

App code changes frequently

Dependencies donâ€™t

This improves:
âœ” Build speed
âœ” CI efficiency

ğŸ”¹ EXPOSE 5000
What it does

Documents that container listens on port 5000

Helps Docker & Kubernetes networking

ğŸ”‘ MUST KNOW

EXPOSE does NOT publish port

-p in docker run publishes it

Interview Trap â—

EXPOSE alone does NOT make app accessible

Correct answer:

Port mapping is done via docker run -p or Kubernetes Service.

ğŸ”¹ CMD ["python", "app/main.py"]
What it does

Defines default command when container starts

ğŸ”‘ CMD vs RUN (IMPORTANT)
RUN	CMD
Executes at build time	Executes at runtime
Creates image layer	Starts container
Cannot be overridden easily	Can be overridden
ğŸ”‘ Why JSON array syntax?

Avoids shell issues

Better signal handling

Recommended by Docker

ğŸ”‘ ENTRYPOINT vs CMD (GOOD TO KNOW)

CMD â†’ default command

ENTRYPOINT â†’ fixed command

We use CMD because:
âœ” Simpler
âœ” Flexible

5ï¸âƒ£ How This Dockerfile Is Used in CI/CD
GitHub
  â†“
Jenkins
  â†“
docker build
  â†“
Docker image
  â†“
Artifact Registry
  â†“
GKE


ğŸ‘‰ Same Dockerfile used everywhere

6ï¸âƒ£ Real Interview Question & Answer
â“ Why is Dockerfile layered?

Answer:

â€œDocker images are built in layers to enable caching and faster rebuilds. Only layers affected by changes are rebuilt.â€

7ï¸âƒ£ Summary (What You MUST Remember)

ğŸ”‘ Dockerfile = image blueprint
ğŸ”‘ Order matters
ğŸ”‘ Base image version must be fixed
ğŸ”‘ Layer caching improves CI speed
ğŸ”‘ Same image used in dev, CI & prod