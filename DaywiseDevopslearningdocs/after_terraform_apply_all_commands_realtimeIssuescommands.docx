1ï¸âƒ£ FULL END-TO-END FLOW
(From Terraform Apply â†’ App Running on GKE â†’ Errors â†’ Fixes)
This is the exact flow we followed (no missing steps).

ğŸ” A. Infrastructure Creation (Terraform)
Flow
Terraform code
 â†’ terraform init
 â†’ terraform plan
 â†’ terraform apply
 â†’ GKE cluster + node pool created

Commands
cd terraform
terraform init
terraform plan -var="project_id=velvety-maker-480912-u3"
terraform apply -var="project_id=velvety-maker-480912-u3"

Errors we faced & fixes
ErrorWhyFix403 GKE API disabledAPI not enabledgcloud services enable container.googleapis.comTerraform auth failedADC not configuredgcloud auth application-default login --no-launch-browsergcloud services enable failedgcloud CLI not logged ingcloud auth login --no-launch-browser

ğŸ” B. kubectl Connection to GKE
Flow
GKE created
 â†’ kubectl configured
 â†’ Node visible

Commands
gcloud container clusters get-credentials school-gke-cluster \
  --zone us-central1-a \
  --project velvety-maker-480912-u3

kubectl get nodes

Error we faced
gke-gcloud-auth-plugin not found

Fix
sudo apt install google-cloud-sdk-gke-gcloud-auth-plugin
export USE_GKE_GCLOUD_AUTH_PLUGIN=True


ğŸ” C. Application Deployment
Flow
Docker image (GAR)
 â†’ Kubernetes Deployment
 â†’ Pod running

Deployment command
kubectl apply -f k8s-deployment.yaml
kubectl get pods

Errors we faced
ErrorMeaningFixImagePullBackOffWrong image tagCorrect tag + reapplyCrashLoopBackOffApp errorCheck logs
Commands used:
kubectl describe pod <pod>
kubectl logs <pod>


ğŸ” D. Exposing Application
Flow
Pod
 â†’ Service (LoadBalancer)
 â†’ External IP
 â†’ Browser

Commands
kubectl apply -f k8s-service.yaml
kubectl get svc

Errors we faced
ErrorWhyFixService not foundYAML not appliedkubectl applyEXTERNAL-IP pendingLB provisioningWait

ğŸ” E. Rolling Update & Redeploy
Flow
Code change
 â†’ Jenkins builds new image
 â†’ Deployment updated
 â†’ kubectl apply
 â†’ Rolling update

Commands
kubectl rollout status deployment school-app
kubectl rollout history deployment school-app
kubectl rollout undo deployment school-app


ğŸ” F. Cleanup
Flow
Disable deletion protection
 â†’ terraform destroy

Commands
terraform apply   # deletion_protection = false
terraform destroy


2ï¸âƒ£ LINUX â€“ 25 MOST IMPORTANT COMMANDS
(4+ Years DevOps â€“ REAL USE)
ğŸ”¹ System & Resource Monitoring
top
htop
uptime
free -h
vmstat
iostat
mpstat

ğŸ”¹ Disk & Filesystem
df -h
du -sh *
lsblk
mount
umount

ğŸ”¹ Processes
ps aux
ps -ef
kill -9 <pid>
nice
renice

ğŸ”¹ Logs & Services
journalctl
journalctl -u docker
journalctl -u kubelet
systemctl status docker
systemctl restart docker

ğŸ”¹ Permissions (VERY IMPORTANT)
chmod 755 file
chmod -R 644 folder
chown user:group file
id
whoami

ğŸ‘‰ Interview focus: CPU spike, disk full, permission denied, process hung.

3ï¸âƒ£ KUBERNETES â€“ 30 COMMANDS (PRODUCTION GRADE)
ğŸ”¹ Basic Visibility
kubectl get pods
kubectl get svc
kubectl get deploy
kubectl get nodes
kubectl get all

ğŸ”¹ Deep Inspection (MOST IMPORTANT)
kubectl describe pod <pod>
kubectl describe deployment <deploy>
kubectl describe svc <svc>

ğŸ”¹ Logs (DAY-TO-DAY WORK)
kubectl logs <pod>
kubectl logs -f <pod>
kubectl logs <pod> --previous

ğŸ”¹ Exec into Pod
kubectl exec -it <pod> -- /bin/sh

ğŸ”¹ Resource Usage
kubectl top pods
kubectl top nodes

ğŸ”¹ Rollout & Recovery
kubectl rollout status deployment <name>
kubectl rollout history deployment <name>
kubectl rollout undo deployment <name>

ğŸ”¹ Scaling & Healing
kubectl scale deployment school-app --replicas=3
kubectl delete pod <pod>

ğŸ‘‰ Kubernetes self-healing is core interview topic.

4ï¸âƒ£ PRODUCTION FAILURE SCENARIOS (YOU MUST PRACTICE)
ğŸ”¥ Scenario 1: App crash
kubectl logs pod
kubectl describe pod

ğŸ”¥ Scenario 2: Image pull failure
kubectl describe pod

ğŸ”¥ Scenario 3: No traffic
kubectl describe svc
kubectl get endpoints

ğŸ”¥ Scenario 4: High CPU
kubectl top pods
kubectl top nodes

ğŸ”¥ Scenario 5: Bad release
kubectl rollout undo deployment school-app


5ï¸âƒ£ DOCKER â€“ 25 COMMANDS (CI + PROD)
ğŸ”¹ Images & Containers
docker images
docker ps
docker ps -a
docker inspect <container>

ğŸ”¹ Logs & Exec
docker logs <container>
docker exec -it <container> sh

ğŸ”¹ Build & Cleanup
docker build -t app .
docker tag
docker push
docker rmi
docker system prune

ğŸ”¹ Networking
docker port <container>
docker network ls
docker network inspect


6ï¸âƒ£ BEST PLAN FOR TODAY (HONEST RECOMMENDATION)
âŒ NOT recommended
Trying Linux + Docker + Kubernetes + Git all today

âœ… RECOMMENDED 3-DAY OPERATION PLAN
ğŸŸ¢ TODAY â€“ Kubernetes Operations (BEST ROI)


Logs


Failures


Rollbacks


Scaling


Zero-downtime deploy


ğŸŸ¡ DAY 2 â€“ Linux + Docker


CPU/memory/disk


Logs


Permissions


Container internals


ğŸ”µ DAY 3 â€“ Git + CI/CD


Branching


Conflicts


Rollbacks


Bad commits



ğŸ¯ NEXT ACTION (START NOW)
Since infra is destroyed:
ğŸ‘‰ Step 1: Re-create GKE using Terraform
ğŸ‘‰ Step 2: Deploy app again
ğŸ‘‰ Step 3: Start Kubernetes failure scenarios (guided)
Reply with one line:
â€œRecreate GKE cluster and start Kubernetes production practiceâ€
And today we will work like real on-call DevOps engineers ğŸ’ª